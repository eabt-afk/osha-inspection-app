<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>OSHA Self-Inspection</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: system-ui, sans-serif;
      background: #f5f5f5;
      color: #222;
      padding: 0.75rem;
    }

    .app-shell {
      max-width: 720px;
      margin: 0 auto;
      background: #fff;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
      overflow: hidden;
      min-height: 92vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 0.85rem 1rem;
      border-bottom: 1px solid #eee;
    }

    header h1 { font-size: 1rem; font-weight: 650; }
    header small { font-size: 0.75rem; color: #666; display:block; margin-top: 0.15rem; }

    .setup {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid #eee;
      background: #fafafa;
      display: flex;
      flex-direction: column;
      gap: 0.55rem;
    }

    .row {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      align-items: center;
    }

    input, select, textarea {
      font: inherit;
    }

    .setup input, .setup select {
      flex: 1;
      min-width: 180px;
      font-size: 0.85rem;
      padding: 0.45rem 0.55rem;
      border-radius: 8px;
      border: 1px solid #ddd;
      background: #fff;
    }

    .btn {
      border: none;
      border-radius: 999px;
      padding: 0.45rem 0.85rem;
      font-size: 0.85rem;
      cursor: pointer;
      white-space: nowrap;
    }

    .btn-primary { background: #0070f3; color: #fff; }
    .btn-secondary { background: #e5e7eb; color: #111827; }
    .btn-success { background: #22c55e; color: #fff; }
    .btn:disabled { opacity: 0.65; cursor: default; }

    .content {
      flex: 1;
      padding: 0.85rem 1rem 1rem;
      display: flex;
      flex-direction: column;
      gap: 0.75rem;
    }

    .hidden { display: none !important; }

    .progress {
      display: flex;
      justify-content: space-between;
      gap: 0.75rem;
      align-items: baseline;
      color: #666;
      font-size: 0.82rem;
    }

    .card {
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 0.85rem;
      background: #fff;
    }

    .badge {
      display: inline-block;
      font-size: 0.72rem;
      padding: 0.18rem 0.55rem;
      border-radius: 999px;
      background: #eef2ff;
      color: #3730a3;
      margin-bottom: 0.45rem;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .q-title {
      font-size: 0.98rem;
      font-weight: 650;
      margin-bottom: 0.5rem;
      line-height: 1.25;
    }

    .q-full {
      font-size: 0.9rem;
      line-height: 1.35;
      background: #f9fafb;
      border-radius: 10px;
      padding: 0.65rem 0.7rem;
      border: 1px solid #eee;
    }

    .status-buttons {
      display: flex;
      gap: 0.45rem;
      flex-wrap: wrap;
      margin-top: 0.65rem;
    }

    .status-btn {
      flex: 1;
      min-width: 120px;
      border-radius: 999px;
      padding: 0.45rem;
      font-size: 0.85rem;
      border: 1px solid #ddd;
      background: #fff;
      cursor: pointer;
    }

    .status-btn.active {
      border-color: #0070f3;
      background: #e0f2fe;
      color: #0369a1;
      font-weight: 650;
    }

    .extras {
      display: flex;
      flex-direction: column;
      gap: 0.45rem;
      margin-top: 0.7rem;
    }

    .extras label {
      font-size: 0.82rem;
      font-weight: 650;
    }

    textarea {
      width: 100%;
      min-height: 70px;
      font-size: 0.85rem;
      padding: 0.55rem;
      border-radius: 10px;
      border: 1px solid #ddd;
      resize: vertical;
    }

    .photo-preview {
      display: flex;
      gap: 0.35rem;
      flex-wrap: wrap;
      margin-top: 0.35rem;
    }

    .photo-preview img {
      width: 74px;
      height: 74px;
      object-fit: cover;
      border-radius: 8px;
      border: 1px solid #ddd;
    }

    .nav {
      display: flex;
      justify-content: space-between;
      gap: 0.5rem;
      margin-top: 0.85rem;
    }

    .footer {
      border-top: 1px solid #eee;
      background: #fafafa;
      padding: 0.75rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
    }

    .footer small { color: #666; font-size: 0.8rem; }

    @media (max-width: 420px) {
      body { padding: 0.5rem; }
      .setup input, .setup select { min-width: 140px; }
      .status-btn { min-width: 100px; }
      .q-title { font-size: 0.95rem; }
    }
  </style>
</head>

<body>
<div class="app-shell">
  <header>
    <h1>OSHA Self-Inspection</h1>
    <small>Select an area, then answer questions one at a time. “Observed?” questions can skip entire sections.</small>
  </header>

  <!-- SETUP (area required before loading questions) -->
  <div class="setup" id="setup">
    <div class="row">
      <input id="inspectorName" type="text" placeholder="Inspector name (required)" />
      <input id="inspectorEmail" type="email" placeholder="Email (required)" />
    </div>
    <div class="row">
      <select id="areaSelect" aria-label="Area">
        <option value="">Loading areas…</option>
      </select>
      <button class="btn btn-primary" id="startBtn" disabled>Start inspection</button>
    </div>
    <small id="setupHint">Choose an area to load the right checklist.</small>
  </div>

  <!-- QUESTION VIEW -->
  <div class="content hidden" id="wizard">
    <div class="progress">
      <div><span id="progressText">Question 0 of 0</span></div>
      <div><span id="progressCat"></span></div>
    </div>

    <div class="card">
      <div class="badge" id="qCategory">Category</div>
      <div class="q-title" id="qShort">Short issue</div>
      <div class="q-full" id="qFull">Full question text…</div>

      <div class="status-buttons">
        <button class="status-btn" id="btnYes">✔ Yes</button>
        <button class="status-btn" id="btnNo">❌ No</button>
        <button class="status-btn" id="btnNA">➖ N/A</button>
      </div>

      <div class="extras">
        <div>
          <label for="commentInput">Comments / Notes (optional)</label>
          <textarea id="commentInput" placeholder="Add context, location, follow-up needed, etc."></textarea>
        </div>

        <div>
          <label for="photoInput">Photos (optional)</label>
          <input type="file" id="photoInput" accept="image/*" multiple />
          <div class="photo-preview" id="photoPreview"></div>
        </div>
      </div>

      <div class="nav">
        <button class="btn btn-secondary" id="prevBtn">Back</button>
        <button class="btn btn-primary" id="nextBtn">Next</button>
      </div>
    </div>
  </div>

  <!-- FOOTER SUBMIT -->
  <div class="footer">
    <small id="footerStatus">Not started</small>
    <button class="btn btn-success" id="submitBtn" disabled>Submit</button>
  </div>
</div>

<script>
/**
 * CONFIG
 * - SCRIPT_URL is your deployed Apps Script web app URL (ends in /exec)
 */
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbznXNi6HRD8qpn3whwdxsj9X0dq7xdii-Gn7pPqzsNvnGoJQ1G5ephp1yhUlnqd-qW1/exec";
const STORAGE_KEY = "osha_wizard_v1";

/**
 * OBSERVED QUESTIONS (by ID) — you provided these
 * When user answers NO to an observed question, we skip all upcoming questions with the same Followup_Group.
 */
const OBSERVED_IDS = new Set([7, 13, 23, 28, 35, 48]);

/**
 * DOM
 */
const setupEl = document.getElementById("setup");
const wizardEl = document.getElementById("wizard");
const startBtn = document.getElementById("startBtn");
const submitBtn = document.getElementById("submitBtn");

const inspectorNameInput = document.getElementById("inspectorName");
const inspectorEmailInput = document.getElementById("inspectorEmail");
const areaSelect = document.getElementById("areaSelect");
const setupHint = document.getElementById("setupHint");
const footerStatus = document.getElementById("footerStatus");

const progressText = document.getElementById("progressText");
const progressCat = document.getElementById("progressCat");

const qCategory = document.getElementById("qCategory");
const qShort = document.getElementById("qShort");
const qFull = document.getElementById("qFull");

const btnYes = document.getElementById("btnYes");
const btnNo  = document.getElementById("btnNo");
const btnNA  = document.getElementById("btnNA");

const commentInput = document.getElementById("commentInput");
const photoInput = document.getElementById("photoInput");
const photoPreview = document.getElementById("photoPreview");

const prevBtn = document.getElementById("prevBtn");
const nextBtn = document.getElementById("nextBtn");

/**
 * STATE
 */
let AREAS = [];
let QUESTION_BANK = [];    // normalized questions
let FLOW = [];             // area-filtered, active, sorted questions used in this run
let idx = 0;               // current index in FLOW

// answers keyed by question id
let answers = new Map();   // id -> {status:'yes'|'no'|'na', comments:'', photos:[base64...]}

// set of followup groups to skip (when observed==no)
let skipGroups = new Set();

function safeTrim(v) { return String(v ?? "").trim(); }
function isTrue(v) { return String(v ?? "").toUpperCase() === "TRUE"; }

/**
 * JSONP GET (GitHub Pages safe)
 */
function apiGet(action) {
  return new Promise((resolve, reject) => {
    const cb = "cb_" + action + "_" + Math.random().toString(36).slice(2);
    const script = document.createElement("script");

    window[cb] = (data) => {
      try {
        delete window[cb];
        script.remove();
        if (!data || data.result !== "success") return reject(new Error(`API ${action} failed`));
        resolve(data.rows || []);
      } catch (err) {
        reject(err);
      }
    };

    script.onerror = () => {
      delete window[cb];
      script.remove();
      reject(new Error(`Failed to load API ${action}`));
    };

    script.src = `${SCRIPT_URL}?action=${encodeURIComponent(action)}&callback=${encodeURIComponent(cb)}`;
    document.body.appendChild(script);
  });
}

/**
 * Normalize rows from Question_Bank
 * Expected headers include:
 * ID, Category, ShortIssue, FullIssue, Area_Tags, Active, Requires_Photo, Requires_Comment, Followup_Group, Order
 */
function normalizeQuestionRow(row) {
  const id = Number(safeTrim(row.ID));
  return {
    id,
    category: safeTrim(row.Category),
    shortIssue: safeTrim(row.ShortIssue),
    fullIssue: safeTrim(row.FullIssue),
    areaTags: safeTrim(row.Area_Tags || "ALL"),
    active: isTrue(row.Active),
    requiresPhoto: isTrue(row.Requires_Photo),
    requiresComment: isTrue(row.Requires_Comment),
    followupGroup: safeTrim(row.Followup_Group || ""),
    order: Number(row.Order || 9999),
  };
}

function areaAllows(q, areaId) {
  const tags = safeTrim(q.areaTags || "ALL").split(",").map(t => t.trim()).filter(Boolean);
  return tags.includes("ALL") || tags.includes(areaId);
}

/**
 * Persistence (so if someone refreshes mid-inspection, they can recover)
 */
function saveState() {
  const obj = {
    idx,
    skipGroups: Array.from(skipGroups),
    answers: Array.from(answers.entries()),
    areaId: areaSelect.value || ""
  };
  localStorage.setItem(STORAGE_KEY, JSON.stringify(obj));
}

function clearState() {
  localStorage.removeItem(STORAGE_KEY);
}

function loadStateMaybe() {
  const raw = localStorage.getItem(STORAGE_KEY);
  if (!raw) return false;
  try {
    const parsed = JSON.parse(raw);
    if (parsed && Array.isArray(parsed.answers)) {
      idx = Number(parsed.idx || 0);
      skipGroups = new Set(parsed.skipGroups || []);
      answers = new Map(parsed.answers || []);
      if (parsed.areaId) areaSelect.value = parsed.areaId;
      return true;
    }
  } catch {}
  return false;
}

/**
 * UI helpers
 */
function setStatusButtons(status) {
  [btnYes, btnNo, btnNA].forEach(b => b.classList.remove("active"));
  if (status === "yes") btnYes.classList.add("active");
  if (status === "no")  btnNo.classList.add("active");
  if (status === "na")  btnNA.classList.add("active");
}

function setPhotosPreview(photos) {
  photoPreview.innerHTML = "";
  (photos || []).forEach(src => {
    const img = document.createElement("img");
    img.src = src;
    photoPreview.appendChild(img);
  });
}

function currentQuestion() {
  return FLOW[idx] || null;
}

function updateFooter() {
  const answeredCount = Array.from(answers.values()).filter(a => a && a.status).length;
  footerStatus.textContent = `Answered ${answeredCount} / ${FLOW.length}`;
  submitBtn.disabled = (answeredCount === 0);
}

/**
 * Navigation with skipping
 */
function isSkippedQuestion(q) {
  if (!q) return true;
  if (!q.followupGroup) return false;
  return skipGroups.has(q.followupGroup);
}

function jumpToNextValid(fromIndex) {
  let j = fromIndex;
  while (j < FLOW.length && isSkippedQuestion(FLOW[j])) j++;
  return j;
}

function jumpToPrevValid(fromIndex) {
  let j = fromIndex;
  while (j >= 0 && isSkippedQuestion(FLOW[j])) j--;
  return j;
}

/**
 * Render current question
 */
function render() {
  const q = currentQuestion();
  if (!q) {
    // finished
    wizardEl.classList.add("hidden");
    footerStatus.textContent = `Ready to submit — ${Array.from(answers.values()).filter(a => a.status).length} answered`;
    submitBtn.disabled = false;
    return;
  }

  // Progress
  progressText.textContent = `Question ${idx + 1} of ${FLOW.length}`;
  progressCat.textContent = q.category || "";

  // Question text
  qCategory.textContent = q.category || "";
  qShort.textContent = q.shortIssue || "";
  qFull.textContent = q.fullIssue || "";

  // Load existing answer if any
  const a = answers.get(q.id) || { status: null, comments: "", photos: [] };
  setStatusButtons(a.status);
  commentInput.value = a.comments || "";
  setPhotosPreview(a.photos || []);
  photoInput.value = "";

  // Buttons
  prevBtn.disabled = (jumpToPrevValid(idx - 1) < 0);
  nextBtn.textContent = (idx >= FLOW.length - 1) ? "Finish" : "Next";

  updateFooter();
  saveState();
}

function setStatus(status) {
  const q = currentQuestion();
  if (!q) return;

  const existing = answers.get(q.id) || { status: null, comments: "", photos: [] };
  answers.set(q.id, { ...existing, status });
  setStatusButtons(status);

  // OBSERVED? logic:
  // If this is an observed question and user answers NO,
  // then skip all questions sharing its followupGroup.
  if (OBSERVED_IDS.has(q.id) && status === "no" && q.followupGroup) {
    skipGroups.add(q.followupGroup);
  }

  // If they change observed from NO -> YES/NA, remove the skip
  if (OBSERVED_IDS.has(q.id) && status !== "no" && q.followupGroup) {
    skipGroups.delete(q.followupGroup);
  }

  updateFooter();
  saveState();
}

/**
 * Wire status buttons
 */
btnYes.onclick = () => setStatus("yes");
btnNo.onclick  = () => setStatus("no");
btnNA.onclick  = () => setStatus("na");

/**
 * Comments/photos inputs
 */
commentInput.oninput = (e) => {
  const q = currentQuestion(); if (!q) return;
  const existing = answers.get(q.id) || { status: null, comments: "", photos: [] };
  answers.set(q.id, { ...existing, comments: e.target.value });
  saveState();
};

photoInput.onchange = (e) => {
  const q = currentQuestion(); if (!q) return;
  const files = Array.from(e.target.files || []);
  if (!files.length) return;

  const existing = answers.get(q.id) || { status: null, comments: "", photos: [] };
  const photos = Array.isArray(existing.photos) ? [...existing.photos] : [];

  let remaining = files.length;
  files.forEach(file => {
    const reader = new FileReader();
    reader.onload = (evt) => {
      photos.push(evt.target.result);
      remaining--;
      if (remaining === 0) {
        answers.set(q.id, { ...existing, photos });
        setPhotosPreview(photos);
        saveState();
      }
    };
    reader.readAsDataURL(file);
  });
};

/**
 * Next/Back
 * - If a question has no status, we still allow Next (you can enforce if you want)
 * - Next jumps over skipped groups
 */
prevBtn.onclick = () => {
  const j = jumpToPrevValid(idx - 1);
  if (j >= 0) idx = j;
  render();
};

nextBtn.onclick = () => {
  // advance to next valid
  let j = jumpToNextValid(idx + 1);
  if (j >= FLOW.length) {
    // finished
    idx = FLOW.length; // render() will show finish state
    render();
    return;
  }
  idx = j;
  render();
};

/**
 * Load areas + questions, but only build FLOW after user chooses area and clicks Start
 */
async function init() {
  // Load areas
  AREAS = await apiGet("areas");
  const activeAreas = AREAS
    .filter(a => String(a.Active ?? a.active ?? "").toUpperCase() === "TRUE")
    .sort((a,b) => Number(a.Order || 9999) - Number(b.Order || 9999));

  areaSelect.innerHTML = `<option value="">Select area (required)</option>` + activeAreas.map(a => {
    const id = safeTrim(a.Area_ID || a.area_id || "");
    const name = safeTrim(a.Area_Name || a.area_name || id);
    return `<option value="${id}">${name}</option>`;
  }).join("");

  // Load questions
  const qbRows = await apiGet("questions");
  QUESTION_BANK = qbRows.map(normalizeQuestionRow).filter(q => q.active);

  // Enable start only when area selected
  function validateStart() {
    const okArea = !!safeTrim(areaSelect.value);
    startBtn.disabled = !okArea;
    setupHint.textContent = okArea ? "Ready. Click Start inspection." : "Choose an area to load the right checklist.";
  }
  areaSelect.onchange = validateStart;
  validateStart();

  // If user had state saved, allow restore
  const restored = loadStateMaybe();
  if (restored && safeTrim(areaSelect.value)) {
    setupHint.textContent = "Found an in-progress inspection for this device. Click Start to resume.";
    startBtn.disabled = false;
  }
}

startBtn.onclick = () => {
  const areaId = safeTrim(areaSelect.value);
  if (!areaId) { alert("Please select an area."); return; }

  // Build FLOW for this area
  FLOW = QUESTION_BANK
    .filter(q => areaAllows(q, areaId))
    .sort((a,b) => a.order - b.order);

  // If starting fresh (no saved state or mismatched area), reset
  const savedRaw = localStorage.getItem(STORAGE_KEY);
  if (!savedRaw) {
    idx = 0;
    skipGroups = new Set();
    answers = new Map();
  } else {
    // ensure idx is within bounds for this FLOW
    if (idx < 0 || idx >= FLOW.length) idx = 0;
  }

  // Ensure we start on first non-skipped
  idx = jumpToNextValid(idx);
  if (idx >= FLOW.length) idx = 0;

  // Show wizard
  setupEl.classList.add("hidden");
  wizardEl.classList.remove("hidden");

  footerStatus.textContent = "In progress…";
  render();
};

/**
 * Submit
 */
async function submitInspection() {
  const name = inspectorNameInput.value.trim();
  const email = inspectorEmailInput.value.trim();
  const areaId = safeTrim(areaSelect.value);

  if (!name || !email) {
    alert("Please enter your name and email before submitting.");
    return;
  }
  if (!areaId) {
    alert("Please select an area before submitting.");
    return;
  }

  const items = [];
  for (const q of FLOW) {
    const a = answers.get(q.id);
    if (!a || !a.status) continue;

    items.push({
      id: q.id,
      category: q.category,
      shortIssue: q.shortIssue,
      fullIssue: q.fullIssue,
      status: a.status,            // yes | no | na
      photos: a.photos || [],
      comments: a.comments || ""
    });
  }

  if (!items.length) {
    alert("No answers yet.");
    return;
  }

  const payload = { inspectorName: name, inspectorEmail: email, areaId, items };

  submitBtn.disabled = true;
  submitBtn.textContent = "Submitting…";

  try {
    const res = await fetch(SCRIPT_URL, { method: "POST", body: JSON.stringify(payload) });
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); } catch { throw new Error("Could not parse Apps Script response"); }

    if (!res.ok || !data || data.result !== "success") {
      throw new Error(data && data.message ? data.message : "Apps Script error");
    }

    alert("Submitted! Starting a new blank inspection.");

    // clear local state
    clearState();
    idx = 0;
    skipGroups = new Set();
    answers = new Map();

    // reset UI back to setup (keep area selected so they can re-run quickly)
    wizardEl.classList.add("hidden");
    setupEl.classList.remove("hidden");

    // optional: clear inspector info every time
    inspectorNameInput.value = "";
    inspectorEmailInput.value = "";

    footerStatus.textContent = "Not started";
    submitBtn.textContent = "Submit";
    submitBtn.disabled = true;

  } catch (err) {
    console.error(err);
    alert("Submit failed — check console for details.");
  } finally {
    submitBtn.disabled = false;
    submitBtn.textContent = "Submit";
  }
}
submitBtn.onclick = submitInspection;

/**
 * Boot
 */
init().catch(err => {
  console.error(err);
  alert("Failed to load areas/questions. Check console for details.");
});
</script>
</body>
</html>
